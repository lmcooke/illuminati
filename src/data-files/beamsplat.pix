#version 410
#define M_PI 3.1415926535897932384626433832795

uniform vec2 Resolution;
uniform sampler2D zDepth;
uniform int screenHeight;
uniform int screenWidth;

in vec2 start_pt;
in vec2 end_pt;
in vec2 start_v;
in vec2 end_v;
in vec3 power;
in vec3 pos;

out vec4 g3d_FragColor;

// project a on b
float project_dist(vec2 a, vec2 b) {
    return dot(normalize(a), normalize(b)) * length(a);
}

void main(void) {

    //vec2 startpt = start_pt * 0.5 + vec2(0.5);
    //vec2 endpt = end_pt * 0.5 + vec2(0.5);
    vec2 startpt = start_pt;
    vec2 endpt = end_pt;
    vec2 coord = (gl_FragCoord.xy ) / Resolution;

    // TODO account for aspect ratio
    vec2 res = Resolution / Resolution.xx;
    //res = vec2(1.0);
    startpt = startpt * res;
    endpt = endpt * res;
    coord = coord * res;
    vec2 startv = start_v * res;
    vec2 endv = end_v * res;

    vec2 beam = endpt - startpt;
    vec2 nbeam = normalize(beam);

    float proj = project_dist(coord - startpt, beam);
    vec2 pt = startpt + proj * nbeam;

    float s_proj = project_dist(startv, beam);
    float e_proj = project_dist(endv, beam);
    vec2 s_proj_pt = s_proj * nbeam;
    vec2 e_proj_pt = e_proj * nbeam;
    float s_rad = length(startv - s_proj_pt);
    float e_rad = length(endv - e_proj_pt);
    float s_pow = M_PI * pow(s_rad, 2);
    float e_pow = M_PI * pow(e_rad, 2);

    float r = mix(s_rad, e_rad, proj / length(beam));
    float val = length(coord - pt) / r;

    //alternate version using length of perpendiculars projected on beam:
    //float val = length(coord - pt) / (mix(s_rad, e_rad, proj / length(e_proj_pt - s_proj_pt)));

    vec3 powr = power;
    // cross-section of beam with radius r should have pi*r^2 = power
    // (this is computed in geometry shader, but use following line to debug)
    //powr = vec3(0.02) / (M_PI * pow(uv.x, 2)); // hardcoded for debugging
    powr *= 0.005;
    val = sin(acos(val));
    //g3d_FragColor = vec4(val * powr);

    // Check against depth of other stuff on screen;
    vec3 pos2 = (pos) * 0.5 + vec3(0.5);

    vec3 lookup = texture(zDepth, gl_FragCoord.xy / Resolution).xyz;


    if (lookup.z > pos2.z) {
        g3d_FragColor = vec4(powr * val, val);
        //g3d_FragColor = vec4(0.5,0.5,0,0.1);
    } else {
        g3d_FragColor = vec4(0);
    }
    //g3d_FragColor.a = 0.1;

}
